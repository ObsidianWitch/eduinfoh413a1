\section{Exercise 1.1}

\subsection{Implementation}
The program's architecture will be discussed in this section. The main entry
point for the first exercise's program is the \emph{IterativeImprovement/main\_ii.cpp}
file.\\

Command line arguments are parsed using an instance of the \emph{GlobalArgsII}
struct which checks that all arguments are correctly filled. The arguments are
stored in this struct attributes. The arguments which must be specified are
the 3 types of rules (initialisation, pivoting rule and neighbourhood) and the
instance file.\\

\begin{lstlisting}
> ./lop
Usage:./lop -i <initialization_rule (cw|random)>
	-p <pivoting_rule (first|best)>
	-n <neighbourhood (transpose|exchange|insert)>
	-f <instance_file>

> ./lop -i cw -p first -n exchange -f ../instances/N-be75eec_150
...
\end{lstlisting}
\

The arguments are then given to the \emph{RulesFactory} in order to get the
desired instances of an initialization, a neighbourhood and a pivoting rule.
Each rule inherits respectively from the \emph{Initialization},
\emph{Neighbourhood} and \emph{Improvement} abstract classes. By doing so, we
can easily extend the program (adding rules).\\

The body of the algorithm which uses the 3 rules previously defined is described
in the \emph{IterativeImprovement} class.\\

\begin{lstlisting}
void IterativeImprovement::run() {
    Permutation p(instance_.size());

    bool localOptimum = false;
    instance_.evaluate(p1);
    
    while (!localOptimum) {
        Permutation p2 = improvement_.improve(p1, neighbourhood_);
        
        localOptimum = (p1 == p2);
        p1 = p2;
    }
}
\end{lstlisting}
\

The two main classs used in this program are the \emph{Instance} and
\emph{Permutation} classes. The first one loads a matrix from an instance file
and stores it in a 2D vector. The second one contains an array representing the
permutation concept described in the subject's slides.\\

The \textbf{Instance::evaluate()} method is used to compute an instance's score
with the help of a permutation. The following formula corresponds to the sum
computed by this method:\\
$\sum_{i=0}^{n-1} \sum_{j=i+1}^{n-1} m(\pi[i], \pi[j])$, with $\pi$ a permutation.\\

We do not need to recompute the sum from each cells between two permutations,
there are cells which can be reused: $newScore = oldScore - deltaOldScore + deltaNewScore$ with \emph{deltaOldScores} the cells in the old permutation which were modified
in the new permutation and \emph{deltaNewScores} the cells in the new permutation
which were modified in the new permutation. We define the following boolean
variables in order to determine which cells are in common :\\

\begin{lstlisting}
bool iInPair = (i == pair.first) || (i == pair.second);
bool jInPair = (j == pair.first) || (j == pair.second);

bool inCommon = (!iInPair && !jInPair)
    || (i == pair.first && !jInPair && j > pair.second)
    || (i == pair.second && !jInPair && j > pair.first)
    || (j == pair.first && !iInPair && i < pair.second)
    || (j == pair.second && !iInPair && i < pair.first);
\end{lstlisting}
\

\noindent The \emph{inCommon} variable can then be inverted in order to retrieve the
modified cells.

\newpage

\subsection{Results}

As described previously, problems were encountered regarding the computation time
of algorithms with the exchange and insert neighbourhoods. These neighbourhoods
are large and as such take a long time to compute. It would not be feasible to
execute all the rules combination with all the instances, when the exchange
neighbourhood with first improvement and a 150*150 instance takes more than
100 seconds.\\

Optimisations regarding the sum in the evaluation of the score were made
(ignoring the cells which were not modified in the sum), but it was not
sufficient to reduce the computation time. Though, it did improve the
computation time: from 300 seconds to 100 seconds for the case described in the
previous paragraph.\\

One method to reduce the computation time would have been to proceed to
neighbourhood pruning in order to remove some neighbours which would not have
improved score.\\

Although the results do not really have any significance, the scripts were run
on simplified neighbourhoods in order to prove that they work as intended. To
reproduce the generation of these results, the \emph{oldNeighbourhoods} branch
can be switched to in \emph{git}.\\

The \emph{script/generate\_experiments.lua} script generates all experiments from
all the rule combinations and instances in a separate file for each rule
combination. The file format and an example can be seen below.\\

\begin{lstlisting}
instance_name score best_known_score relative_percentage_deviation computation_time

N-be75eec_150 2850321 3482828 18.160730303076 1.10763
N-be75eec_250 7456782 8893533 16.155008363943 7.79982
N-be75np_150 5991561 7174325 16.486066633446 0.997437
N-be75np_250 14820463 17814072 16.804742902128 7.66058
...
\end{lstlisting}

The \emph{script/compute\_averages.lua} script takes all the data from the
previously generated experiments files and computes averages from it.\\

\begin{lstlisting}
experiment_name average_delta time_sum time_average

ii_cw_best_exchange 17.277346692163 333 4.2692307692308
ii_cw_best_insert 17.084249592579 321 4.1153846153846
ii_cw_best_transpose 17.549047663734 243 3.1153846153846
...
\end{lstlisting}



\newpage

\subsection{Tests}
% TODO
\newpage
